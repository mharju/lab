shadow$provide[50]=function(mc,Nb,Tb,Hb){(function(m){"object"===typeof Hb&&"object"===typeof Tb?m(Nb(1)):"function"===typeof define&&define.amd?define(["../../lib/codemirror"],m):m(CodeMirror)})(function(m){m.defineMode("clojure",function(ka){function Fa(O,Y){if(O.eatSpace()||O.eat(","))return["space",null];if(O.match(R))return[null,"number"];if(O.match(ja))return[null,"string-2"];if(O.eat(/^"/))return(Y.tokenize=u)(O,Y);if(O.eat(/^[(\[{]/))return["open","bracket"];if(O.eat(/^[)\]}]/))return["close",
"bracket"];if(O.eat(/^;/))return O.skipToEnd(),["space","comment"];if(O.eat(/^[#'@^`~]/))return[null,"meta"];var E=O.match(N);E=E&&E[0];return E?"comment"===E&&"("===Y.lastToken?(Y.tokenize=B)(O,Y):na(E,Q)||":"===E.charAt(0)?["symbol","atom"]:na(E,ba)||na(E,W)?["symbol","keyword"]:"("===Y.lastToken?["symbol","builtin"]:["symbol","variable"]:(O.next(),O.eatWhile(function(X){return!na(X,H)}),[null,"error"])}function u(O,Y){for(var E=!1,X;X=O.next();){if('"'===X&&!E){Y.tokenize=Fa;break}E=!E&&"\\"===
X}return[null,"string"]}function B(O,Y){for(var E=1,X;X=O.next();)if(")"===X&&E--,"("===X&&E++,0===E){O.backUp(1);Y.tokenize=Fa;break}return["space","comment"]}function ha(O){for(var Y={},E=0;E<O.length;++E)Y[O[E]]=!0;return Y}function na(O,Y){if(Y instanceof RegExp)return Y.test(O);if(Y instanceof Object)return Y.propertyIsEnumerable(O)}var Ca=["false","nil","true"],La=". catch def do if monitor-enter monitor-exit new quote recur set! throw try var".split(" "),ea="* *' *1 *2 *3 *agent* *allow-unresolved-vars* *assert* *clojure-version* *command-line-args* *compile-files* *compile-path* *compiler-options* *data-readers* *default-data-reader-fn* *e *err* *file* *flush-on-newline* *fn-loader* *in* *math-context* *ns* *out* *print-dup* *print-length* *print-level* *print-meta* *print-namespace-maps* *print-readably* *read-eval* *reader-resolver* *source-path* *suppress-read* *unchecked-math* *use-context-classloader* *verbose-defrecords* *warn-on-reflection* + +' - -' -\x3e -\x3e\x3e -\x3eArrayChunk -\x3eEduction -\x3eVec -\x3eVecNode -\x3eVecSeq -cache-protocol-fn -reset-methods .. / \x3c \x3c\x3d \x3d \x3d\x3d \x3e \x3e\x3d EMPTY-NODE Inst StackTraceElement-\x3evec Throwable-\x3emap accessor aclone add-classpath add-watch agent agent-error agent-errors aget alength alias all-ns alter alter-meta! alter-var-root amap ancestors and any? apply areduce array-map as-\x3e aset aset-boolean aset-byte aset-char aset-double aset-float aset-int aset-long aset-short assert assoc assoc! assoc-in associative? atom await await-for await1 bases bean bigdec bigint biginteger binding bit-and bit-and-not bit-clear bit-flip bit-not bit-or bit-set bit-shift-left bit-shift-right bit-test bit-xor boolean boolean-array boolean? booleans bound-fn bound-fn* bound? bounded-count butlast byte byte-array bytes bytes? case cast cat char char-array char-escape-string char-name-string char? chars chunk chunk-append chunk-buffer chunk-cons chunk-first chunk-next chunk-rest chunked-seq? class class? clear-agent-errors clojure-version coll? comment commute comp comparator compare compare-and-set! compile complement completing concat cond cond-\x3e cond-\x3e\x3e condp conj conj! cons constantly construct-proxy contains? count counted? create-ns create-struct cycle dec dec' decimal? declare dedupe default-data-readers definline definterface defmacro defmethod defmulti defn defn- defonce defprotocol defrecord defstruct deftype delay delay? deliver denominator deref derive descendants destructure disj disj! dissoc dissoc! distinct distinct? doall dorun doseq dosync dotimes doto double double-array double? doubles drop drop-last drop-while eduction empty empty? ensure ensure-reduced enumeration-seq error-handler error-mode eval even? every-pred every? ex-data ex-info extend extend-protocol extend-type extenders extends? false? ffirst file-seq filter filterv find find-keyword find-ns find-protocol-impl find-protocol-method find-var first flatten float float-array float? floats flush fn fn? fnext fnil for force format frequencies future future-call future-cancel future-cancelled? future-done? future? gen-class gen-interface gensym get get-in get-method get-proxy-class get-thread-bindings get-validator group-by halt-when hash hash-combine hash-map hash-ordered-coll hash-set hash-unordered-coll ident? identical? identity if-let if-not if-some ifn? import in-ns inc inc' indexed? init-proxy inst-ms inst-ms* inst? instance? int int-array int? integer? interleave intern interpose into into-array ints io! isa? iterate iterator-seq juxt keep keep-indexed key keys keyword keyword? last lazy-cat lazy-seq let letfn line-seq list list* list? load load-file load-reader load-string loaded-libs locking long long-array longs loop macroexpand macroexpand-1 make-array make-hierarchy map map-entry? map-indexed map? mapcat mapv max max-key memfn memoize merge merge-with meta method-sig methods min min-key mix-collection-hash mod munge name namespace namespace-munge nat-int? neg-int? neg? newline next nfirst nil? nnext not not-any? not-empty not-every? not\x3d ns ns-aliases ns-imports ns-interns ns-map ns-name ns-publics ns-refers ns-resolve ns-unalias ns-unmap nth nthnext nthrest num number? numerator object-array odd? or parents partial partition partition-all partition-by pcalls peek persistent! pmap pop pop! pop-thread-bindings pos-int? pos? pr pr-str prefer-method prefers primitives-classnames print print-ctor print-dup print-method print-simple print-str printf println println-str prn prn-str promise proxy proxy-call-with-super proxy-mappings proxy-name proxy-super push-thread-bindings pvalues qualified-ident? qualified-keyword? qualified-symbol? quot rand rand-int rand-nth random-sample range ratio? rational? rationalize re-find re-groups re-matcher re-matches re-pattern re-seq read read-line read-string reader-conditional reader-conditional? realized? record? reduce reduce-kv reduced reduced? reductions ref ref-history-count ref-max-history ref-min-history ref-set refer refer-clojure reify release-pending-sends rem remove remove-all-methods remove-method remove-ns remove-watch repeat repeatedly replace replicate require reset! reset-meta! reset-vals! resolve rest restart-agent resultset-seq reverse reversible? rseq rsubseq run! satisfies? second select-keys send send-off send-via seq seq? seqable? seque sequence sequential? set set-agent-send-executor! set-agent-send-off-executor! set-error-handler! set-error-mode! set-validator! set? short short-array shorts shuffle shutdown-agents simple-ident? simple-keyword? simple-symbol? slurp some some-\x3e some-\x3e\x3e some-fn some? sort sort-by sorted-map sorted-map-by sorted-set sorted-set-by sorted? special-symbol? spit split-at split-with str string? struct struct-map subs subseq subvec supers swap! swap-vals! symbol symbol? sync tagged-literal tagged-literal? take take-last take-nth take-while test the-ns thread-bound? time to-array to-array-2d trampoline transduce transient tree-seq true? type unchecked-add unchecked-add-int unchecked-byte unchecked-char unchecked-dec unchecked-dec-int unchecked-divide-int unchecked-double unchecked-float unchecked-inc unchecked-inc-int unchecked-int unchecked-long unchecked-multiply unchecked-multiply-int unchecked-negate unchecked-negate-int unchecked-remainder-int unchecked-short unchecked-subtract unchecked-subtract-int underive unquote unquote-splicing unreduced unsigned-bit-shift-right update update-in update-proxy uri? use uuid? val vals var-get var-set var? vary-meta vec vector vector-of vector? volatile! volatile? vreset! vswap! when when-first when-let when-not when-some while with-bindings with-bindings* with-in-str with-loading-context with-local-vars with-meta with-open with-out-str with-precision with-redefs with-redefs-fn xml-seq zero? zipmap".split(" ");
m.registerHelper("hintWords","clojure",[].concat(Ca,La,ea));var Q=ha(Ca),ba=ha(La),W=ha(ea),aa=ha("-\x3e -\x3e\x3e as-\x3e binding bound-fn case catch comment cond cond-\x3e cond-\x3e\x3e condp def definterface defmethod defn defmacro defprotocol defrecord defstruct deftype do doseq dotimes doto extend extend-protocol extend-type fn for future if if-let if-not if-some let letfn locking loop ns proxy reify struct-map some-\x3e some-\x3e\x3e try when when-first when-let when-not when-some while with-bindings with-bindings* with-in-str with-loading-context with-local-vars with-meta with-open with-out-str with-precision with-redefs with-redefs-fn".split(" ")),
H=/^(?:[\\\[\]\s"(),;@^`{}~]|$)/,R=/^(?:[+\-]?\d+(?:(?:N|(?:[eE][+\-]?\d+))|(?:\.?\d*(?:M|(?:[eE][+\-]?\d+))?)|\/\d+|[xX][0-9a-fA-F]+|r[0-9a-zA-Z]+)?(?=[\\\[\]\s"#'(),;@^`{}~]|$))/,ja=/^(?:\\(?:backspace|formfeed|newline|return|space|tab|o[0-7]{3}|u[0-9A-Fa-f]{4}|x[0-9A-Fa-f]{4}|.)?(?=[\\\[\]\s"(),;@^`{}~]|$))/,N=/^(?:(?:[^\\\/\[\]\d\s"#'(),;@^`{}~.][^\\\[\]\s"(),;@^`{}~.\/]*(?:\.[^\\\/\[\]\d\s"#'(),;@^`{}~.][^\\\[\]\s"(),;@^`{}~.\/]*)*\/)?(?:\/|[^\\\/\[\]\d\s"#'(),;@^`{}~][^\\\[\]\s"(),;@^`{}~]*)*(?=[\\\[\]\s"(),;@^`{}~]|$))/;
return{startState:function(){return{ctx:{prev:null,start:0,indentTo:0},lastToken:null,tokenize:Fa}},token:function(O,Y){O.sol()&&"number"!==typeof Y.ctx.indentTo&&(Y.ctx.indentTo=Y.ctx.start+1);var E=Y.tokenize(O,Y),X=E[0];E=E[1];var ra=O.current();"space"!==X&&("("===Y.lastToken&&null===Y.ctx.indentTo?"symbol"===X&&na(ra,aa)?Y.ctx.indentTo=Y.ctx.start+ka.indentUnit:Y.ctx.indentTo="next":"next"===Y.ctx.indentTo&&(Y.ctx.indentTo=O.column()),Y.lastToken=ra);"open"===X?Y.ctx={prev:Y.ctx,start:O.column(),
indentTo:null}:"close"===X&&(Y.ctx=Y.ctx.prev||Y.ctx);return E},indent:function(O){var Y=O.ctx.indentTo;return"number"===typeof Y?Y:O.ctx.start+1},closeBrackets:{pairs:'()[]{}""'},lineComment:";;"}});m.defineMIME("text/x-clojure","clojure");m.defineMIME("text/x-clojurescript","clojure");m.defineMIME("application/edn","clojure")})}
goog.provide("module$node_modules$codemirror$mode$clojure$clojure");
goog.global. module$node_modules$codemirror$mode$clojure$clojure=shadow.js.require(50, {});
